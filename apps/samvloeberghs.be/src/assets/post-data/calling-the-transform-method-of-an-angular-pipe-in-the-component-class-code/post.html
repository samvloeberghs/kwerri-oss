<section class="entry-content post-body" itemprop="articleBody">

  <h2 id="target-audience">Target audience</h2>

  <p>
    This article is intended to help anybody that is looking for ways to call the <code>transform</code> method in the
    component class code or in any other TypeScript code that has an Injection Context.
  </p>
  <p>
    We will also learn  some other tips & tricks on how to design pipes and how to test them in
    those particular cases.
  </p>

  <h2 id="step-by-step">Introduction</h2>

  <p>
    There are several cases where you would want to reuse the functionality of a pipe in your component class code.
    The most simple example is formatting dates in an Angular component's template. The <code>DatePipe</code>, provided
    by the Angular framework itself, is imported in the providers of the component and then used by piping the value in
    the template.
  </p>
  <p>
    For example, <code>{{currentDate | date : "fullDate"}}</code> would print out something like
    "Friday, September 29, 2023" in the template. If you would like to use the same functionality in the component
    class code, you can inject the <code>DatePipe</code> and then call the <code>transform</code> method manually.
  </p>

  <h4 class="codetitle">Component example:</h4>
  <pre><code class="language-ts line-numbers">import { DatePipe } from '@angular/common';

@Component({
  ...
  providers: [DatePipe]
})
export class ExampleComponent {
  constructor(){
    const currentDate = new Date();
    const formattedDate = inject(DatePipe).transform(currentDate, 'fullDate');
    console.log(formattedDate);
  }
}</code></pre>

  <p class="alert alert--info">
    <strong>Note:</strong> This is not the way I would personally recommend to reuse the functionality of any
    (Angular build-in) pipe. Continue reading to find out better ways.
  </p>

  <h2 id="a-better-way-to-reuse-the-functionality-of-a-pipe">A better way to reuse the functionality of a pipe</h2>

  <h3 id="angular-build-in-pipes">Angular build-in Pipes</h3>

  <p>
    Next to providing common functionality like formatting dates, percentages, currencies or numbers through pipes,
    Angular also exposes the inner working of those pipes directly as export functions. For example, the usecase from
    above, where we injected the <code>DatePipe</code> to be able to use the <code>transform</code> method, can be
    rewritten as follows:
  </p>

  <h4 class="codetitle">Component example, with formatDate:</h4>
  <pre><code class="language-ts line-numbers">import { formatDate } from '@angular/common';

@Component({
    ...
})
export class ExampleComponent {
  constructor(){
    const formattedDate = formatDate(currentDate, 'fullDate');
    console.log(formattedDate);
  }
}</code></pre>

  <p>
    In this case we don't even need to inject the <code>DatePipe</code> anymore, because the <code>formatDate</code> is
    exposed as a pure function directly.
  </p>

  <h3 id="custom-pipes">Custom Pipes</h3>

  <h2 id="conclusion">Conclusion</h2>

  <p>
    There is no wrong or right way of reusing the functionality of any (Angular build-in) pipe.
    It all depends on personal or project-specific preference.
    But at least now you know how I would do it, and I do believe it's the best way :)
  </p>

  <h2 id="further-reading">Further reading</h2>

  <ol class="post__further-reading">
    <li>
      <a href="https://angular.io/guide/pipes-overview" target="_blank" rel="noopener">
        Angular Documentation: Understanding Pipes
      </a>
    </li>
    <li>
        <a href="https://angular.io/api/core/Pipe" target="_blank" rel="noopener">
          Angular Pipe Decorator
        </a>
    </li>
    <li>
        <a href="https://angular.io/guide/styleguide#02-09" target="_blank" rel="noopener">
          Angular Style Guide: Pipe names
        </a>
    </li>
  </ol>

</section>
